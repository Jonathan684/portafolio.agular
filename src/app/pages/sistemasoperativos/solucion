Trabajo Práctico N°2 - Myshell
Patiño, Jonathan Armando
Introducción:
El intérprete de comandos resulta la interfaz más tradicional de un sistema operativo tipo UNIX. Este programa que se ejecuta en modo usuario, funciona en cualquier UNIX que soporte interfaces de caracteres y su función es aceptar comandos ingresados por entrada estándar (teclado), parsearlos, ejecutar la orden y mostrar el resultado en la salida estándar (pantalla), para luego volver a repetir el proceso. En este Trabajo Practico se elabora un programa en lenguaje C sobre GNU/Linux.El mismo consiste en varias secciones que se explican a continuacion. El programa comienza ejecutando el make (makefile), luego se debe decidir si la aplicaciòn se debe ejecutar desde un archivo batchfile o desde el prompt que se ha creado para interpretar los comando ingresados. Myshell permite tener el control de la consola en la cual se pueden utilizar los siguientes comandos:

"cd" para avanzar o retroceder en un directorio, partiendo del directorio actual;
"clr" limpia la pantalla;
"echo comentario" imprime el comentario, y
"quit" cierra la shell.
Cuando se ingresa un comando que no es uno de los nombrados anteriormente se crea un proceso y se intenta ejecutar el comando ingresado. El comando (que se considera un programa a ejecutar) puede estar en varios lugares. Primero se busca el programa en el path actual, para ello se le pasa a execv el path actual y los argumentos del programa, en caso de dar error se ejecutará execvp, el cual busca en la ruta absoluta dentro del árbol del FyleSystem. En caso de que la ejecución del programa tenga éxito, pueden suceder dos alternativas; por una parte, se utiliza un wait para que el programa padre espere por la finalización del hijo; en la segunda se utiliza el wait, pero no se espera hasta que termine para que el padre pueda realizar otra tarea. Para que esto último suceda, se debe agregar al comando el caracter "&". Otra de las utilidades que ofrece myshell es poder redireccionar la salida estándar utilizando los caracteres ">". De esta manera, cuando se ejecute un programa, en vez de utilizar la salida estándar (consola), se puede hacer que se redireccione hacia un archivo, por ejemplo. También se puede redireccionar la entrada estándar. En este caso, se debe utilizar el carácter "<" para tomar los valores desde un archivo pasado por el lado derecho del carácter. Por ejemplo, la sintaxis sería "programa < comando.txt" ; en este caso, el programa que necesita valores para funcionar los toma desde comando.txt, y no de la consola (entrada estándar). También, myshell funciona utilizando las señales. Para este caso, presionando las teclas de Ctrl + C , Ctrl + Z o Ctrl + \ , se activa el manejador de señales en el padre, el cual recibe la señal y mediante la funcion kill se la envía a los procesos hijo. Para lograr esto, se debió cambiar de grupo a los hijos, ya que si no se hacía eso, todos recibían las señales, tanto los procesos hijos como el padre. Por último, myshell puede conectar dos procesos mediante un pipe, el cual permite que la salida estándar de un proceso sea la entrada estándar de otro proceso. Por ejemplo, la función 'last "username" | wc -l' , se lleva a cabo mediante la funcion pipe(). Para finalizar myshell se debe ingresar el comando "fin", el cual recorre una lista de procesos creados y les envía la señal SIGTERM la cual permite que el proceso cierre conexiones y archivos, limpie sus propios búfer, y luego termina el proceso padre mediante un exit(EXIT_SUCCESS).

¿Dónde se encuentran los pipes en el filesystem, que atributos tienen?
int tuberia [2]
Para crear las tuberías se emplea la función pipe(), que abre dos file descriptors y almacena su valor en los dos enteros que contiene el array de fd , el primer file descriptor es abierto como O_RDONLY, es decir, sólo puede ser empleado para lecturas. El segundo, se abre como O_WRONLY, limitando su uso a la escritura; de esta manera se asegura que el pipe sea de un solo sentido: por un extremo se escribe, y por el otro se lee - nunca al revés-.
